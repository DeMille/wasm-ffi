{"version":3,"sources":["webpack:///webpack/bootstrap 05f8d1f5c52206ddd5f8","webpack:///./src/types.js","webpack:///./src/misc.js","webpack:///./src/demangle.js","webpack:///./src/Struct.js","webpack:///./src/index.js","webpack:///./src/Wrapper.js","webpack:///./src/rust.js"],"names":["CustomType","size","opts","isNaN","width","alignment","read","write","view","value","ArrayBuffer","isView","buf","Uint8Array","buffer","byteOffset","byteLength","uint8","set","Signed","get","Unsigned","types","void","int8","int16","int32","uint16","uint32","int64","uint64","float","getFloat32","setFloat32","double","getFloat64","setFloat64","bool","getInt8","setInt8","Pointer","type","parseType","_free","_temp","free","ref","pointer","typedef","isPointer","addr","getUint32","DataView","setUint32","CString","TextEncoder","encode","memory","end","subarray","str","TextDecoder","decode","deref","string","length","data","ArrayType","arr","i","subview","push","values","forEach","aliases","u8","u16","u32","u64","i8","i16","i32","i64","f32","f64","char","uchar","schar","short","ushort","int","uint","long","ulong","longlong","ulonglong","size_t","usize","parseTypeString","name","toLowerCase","Error","Array","isArray","errMsg","assert","vslice","condition","args","msg","strings","map","JSON","stringify","arg","e","split","part","pop","start","demangleStack","symbols","isHash","slice","every","test","replaceAllSymbols","reduce","result","re","replace","demangle","mangled","startsWith","indexOf","sub","endsWith","inner","chars","labels","label","digits","parseInt","join","err","stack","line","_","m1","m2","DATA","Symbol","for","AbstractStructType","obj","temp","Object","entries","key","recursive","freePointers","struct","constructor","fields","field","isStruct","StructType","fieldView","offset","Struct","opt","Map","packed","getOwnPropertyNames","defineProperty","prototype","enumerable","Wrapper","cwrap","ccall","rust","numbers","Set","areValid","undefined","has","fetchAndInstantiate","url","imports","fetch","then","resp","ok","status","wasm","headers","WebAssembly","instantiateStreaming","arrayBuffer","instantiate","instance","signatures","allocations","debug","fn","returnType","argTypes","add","fnName","utils","readString","__readString","bind","writeString","__writeString","writeArray","__writeArray","readStruct","__readStruct","writeStruct","readPointer","__readPointer","writePointer","allocate","__writePointer","__writeStruct","__free","exports","defaults","wrap","raw","r","__out","__in","env","print","console","log","eprint","error","trace","_abort","errCode","_exit","exitCode","_grow","assign","__link","Instance","__wrap","ffi_args","ptr","deallocate","optSize","delete","len","__allocate","__view","allocPointers","ptrType","attach","wrapper","use","call","extend","RustType","RustTuple","tupleTypes","RustVector","Vector","cap","arrayType","RustSlice","Slice","RustString","RString","toString","RustStr","RStr","RustOption","isNonNullable","tagSize","discriminant","Option","isSome","isNone","expect","unwrap","unwrapOr","defaultValue","unwrapOrElse","RustEnum","variants","vtypes","Enum","variant","_set","keys","tag","arms","val","field_1","field_2","max","acc","t","align","tuple","Tuple","vector","String","Str","option","Some","None","enum"],"mappings":"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","file":"wasm-ffi.browser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 05f8d1f5c52206ddd5f8","import { assert, vslice } from './misc';\n\n\n// Makes a type of a given size.\n// Optional read / write methods, just gives a DataView by default.\nclass CustomType {\n  constructor(size, opts = {}) {\n    assert(!isNaN(size), 'Type size must be a number, given: %s', size);\n\n    this.width = size;\n    this.alignment = ('alignment' in opts) ? opts.alignment : size;\n\n    if (opts.read) this.read = opts.read;\n    if (opts.write) this.write = opts.write;\n  }\n\n  read(view) {\n    return view;\n  }\n\n  write(view, value) {\n    assert(value instanceof ArrayBuffer || ArrayBuffer.isView(value),\n      'Value must be an `ArrayBuffer` or a `DataView` (like `Uint8Array`)');\n\n    const buf = (ArrayBuffer.isView(value))\n      ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength)\n      : new Uint8Array(value);\n\n    const uint8 = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n\n    uint8.set(buf);\n  }\n}\n\n\nclass Signed {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getInt${width * 8}`;\n    const set = `setInt${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nclass Unsigned {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getUint${width * 8}`;\n    const set = `setUint${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nconst types = {};\n\ntypes.void = {\n  width: 0,\n  alignment: 0,\n  read: () => null,\n  write: () => {},\n};\n\ntypes.int8 = new Signed(1);\ntypes.int16 = new Signed(2);\ntypes.int32 = new Signed(4);\ntypes.uint8 = new Unsigned(1);\ntypes.uint16 = new Unsigned(2);\ntypes.uint32 = new Unsigned(4);\n\ntypes.int64 = new CustomType(8);\ntypes.uint64 = new CustomType(8);\n\ntypes.float = {\n  width: 4,\n  alignment: 4,\n\n  read(view) {\n    return view.getFloat32(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat32(0, value, true /* little-endian */);\n  },\n};\n\ntypes.double = {\n  width: 8,\n  alignment: 8,\n\n  read(view) {\n    return view.getFloat64(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat64(0, value, true /* little-endian */);\n  },\n};\n\ntypes.bool = {\n  width: 1,\n  alignment: 1,\n\n  read(view) {\n    return !!view.getInt8(0);\n  },\n\n  write(view, value) {\n    view.setInt8(0, (!!value) ? 1 : 0);\n  },\n};\n\n\n// A pointer to some other data type in memory\nclass Pointer {\n  constructor(type, value) {\n    this.type = parseType(type);\n    this.view = null;\n    this._free = null;\n    this._temp = value;\n  }\n\n  attach(view, free) {\n    this.view = view;\n    this._free = free;\n\n    if (this._temp) this.set(this._temp);\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated pointer');\n    return this.type.read(this.view, this._free);\n  }\n\n  set(value) {\n    if (this.view) {\n      this.type.write(this.view, value, this._free);\n    } else {\n      this._temp = value;\n    }\n  }\n\n  free() {\n    assert(this.view, 'Cant free pointer: unallocated / already freed');\n\n    this._free(this.ref(), this.type.width);\n    this._free = null;\n    this.view = null;\n  }\n}\n\ntypes.pointer = function(typedef) {\n  const type = parseType(typedef);\n\n  return {\n    type,\n    width: 4,\n    alignment: 4,\n    isPointer: true,\n\n    read(view, free) {\n      const addr = view.getUint32(0, true /* little-endian */);\n\n      const pointer = new Pointer(type);\n      pointer.view = new DataView(view.buffer, addr, type.width);\n      pointer._free = free;\n\n      return pointer;\n    },\n\n    write(view, value) {\n      assert(value instanceof Pointer, `Trying to write ${value} as a pointer`);\n      assert(value.ref(), 'Cant write pointer, hasnt been allocated yet');\n      view.setUint32(0, value.ref(), true /* little-endian */);\n    },\n  };\n};\n\n\n// A pointer to a null-terminated string\nclass CString {\n  constructor(value, free) {\n    this.type = {\n      isPointer: true,\n      width: null,\n    };\n    this.view = null;\n    this._temp = null;\n    this._free = null;\n\n    if (typeof value === 'string') {\n      this._temp = (new TextEncoder()).encode(value);\n      this.type.width = this._temp.byteLength + 1;\n    }\n\n    if (value instanceof DataView) {\n      this.view = value;\n      this._free = free;\n      this.type.width = value.byteLength;\n    }\n  }\n\n  attach(view, free) {\n    this.view = view;\n    this._free = free;\n\n    if (this._temp) {\n      const memory = new Uint8Array(view.buffer);\n\n      memory.set(this._temp, view.byteOffset);\n      memory[view.byteOffset + this.type.width - 1] = 0;\n    }\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated CString');\n\n    const memory = new Uint8Array(this.view.buffer);\n    const addr = this.view.byteOffset;\n    const end = addr + this.type.width - 1;\n\n    // `subarray` uses the same underlying ArrayBuffer\n    const buf = new Uint8Array(memory.subarray(addr, end));\n    const str = (new TextDecoder()).decode(buf);\n\n    return str;\n  }\n\n  free() {\n    assert(!!this.view, 'Cant free cstring: unallocated / already freed');\n\n    this._free(this.ref(), this.type.width);\n    this._free = null;\n    this.view = null;\n  }\n\n  valueOf() {\n    return this.deref();\n  }\n\n  toString() {\n    return this.deref();\n  }\n}\n\ntypes.string = {\n  width: 4,\n  alignment: 4,\n  isPointer: true,\n\n  read(view, free) {\n    const memory = new Uint8Array(view.buffer);\n    const addr = view.getUint32(0, true /* little-endian */);\n    let end = addr;\n\n    // find null byte\n    while (memory[end]) ++end;\n\n    const length = end - addr + 1;\n    const data = new DataView(view.buffer, addr, length);\n\n    return new CString(data, free);\n  },\n\n  write(view, value) {\n    assert(value instanceof CString, 'value must be a `CString`');\n    assert(value.ref(), 'Cant write CString, hasnt been allocated yet');\n    view.setUint32(0, value.ref(), true /* little-endian */);\n  },\n};\n\n\n// An array (of known size) of sub-types.\nclass ArrayType {\n  constructor(type, length) {\n    this.type = type;\n    this.length = length;\n\n    this.width = type.width * length;\n    this.alignment = type.alignment;\n  }\n\n  read(view, free) {\n    const arr = [];\n\n    for (let i = 0; i <= this.length - 1; i++) {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      arr.push(this.type.read(subview, free));\n    }\n\n    return arr;\n  }\n\n  write(view, values) {\n    assert(values.length === this.length,\n      'Values length does not match struct array length');\n\n    values.forEach((value, i) => {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      this.type.write(subview, value);\n    });\n  }\n}\n\n\n// Maps other names to base types\n//\n// Some questionable decisions:\n//  - char = uint8 (I mean, what do you do, really)\n//  - long = int32 (windows=32, linux=64, wasm is 32bit right now, so...)\n//\nconst aliases = {\n  u8: types.uint8,\n  u16: types.uint16,\n  u32: types.uint32,\n  u64: types.uint64,\n  i8: types.int8,\n  i16: types.int16,\n  i32: types.int32,\n  i64: types.int64,\n  f32: types.float,\n  f64: types.double,\n  char: types.uint8,\n  uchar: types.uint8,\n  schar: types.int8,\n  short: types.int16,\n  ushort: types.uint16,\n  int: types.int32,\n  uint: types.uint32,\n  long: types.int32,\n  ulong: types.uint32,\n  longlong: types.uint64,\n  ulonglong: types.uint64,\n  size_t: types.uint32,\n  usize: types.uint32,\n};\n\n\nfunction parseTypeString(str) {\n  const name = str.toLowerCase();\n\n  if (name in types) return types[name];\n  if (name in aliases) return aliases[name];\n\n  throw new Error(`Parsing unknown type '${str}'`);\n}\n\n\n// parse a type from some type definition.\n// may be a string, an actual type, or an array of types\nfunction parseType(typedef) {\n  if (typeof typedef === 'string') {\n    return parseTypeString(typedef);\n  }\n\n  if (Array.isArray(typedef)) {\n    assert(typedef.length === 2,\n      'Array type needs 2 arguments: [type, length], given: \\n%s', typedef);\n\n    const type = parseType(typedef[0]);\n    const length = typedef[1];\n\n    return new ArrayType(type, length);\n  }\n\n  // make sure its an ok type interface\n  const errMsg = \"Given argument type isn't a proper 'type' interface: \\n%s\";\n  assert('width' in typedef, errMsg, typedef);\n  assert('alignment' in typedef, errMsg, typedef);\n  assert('read' in typedef, errMsg, typedef);\n  assert('write' in typedef, errMsg, typedef);\n\n  return typedef;\n}\n\n\nexport { types, CustomType, Pointer, CString, parseType };\n\n\n\n// WEBPACK FOOTER //\n// ./src/types.js","// simple assert, throws if assertion fails\n// also matches args to %s formatters\nexport function assert(condition, errMsg, ...args) {\n  if (condition) return;\n  if (!args || !args.length) throw new Error(errMsg);\n\n  let msg = '';\n  let strings;\n\n  try {\n    strings = args.map(arg => JSON.stringify(arg, null, 2));\n  } catch (e) {\n    throw new Error(errMsg);\n  }\n\n  errMsg.split('%s').forEach((part) => {\n    msg += part;\n    if (strings.length) msg += strings.pop();\n  });\n\n  throw new Error(msg);\n}\n\n// takes a subslice of a DataView\nexport function vslice(view, start, length) {\n  return new DataView(view.buffer, view.byteOffset + start, length);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc.js","// Rust demangle logic adpated from Alex Crichton's ructc-demangle:\n// http://alexcrichton.com/rustc-demangle/src/rustc_demangle/lib.rs.html\nconst symbols = [\n  [/^_\\$/, '$'],\n  [/\\$C\\$/g, ','],\n  [/\\$SP\\$/g, '@'],\n  [/\\$BP\\$/g, '*'],\n  [/\\$RF\\$/g, '&'],\n  [/\\$LT\\$/g, '<'],\n  [/\\$GT\\$/g, '>'],\n  [/\\$LP\\$/g, '('],\n  [/\\$RP\\$/g, ')'],\n  [/\\$u7e\\$/g, '~'],\n  [/\\$u20\\$/g, ' '],\n  [/\\$u27\\$/g, \"'\"],\n  [/\\$u5b\\$/g, '['],\n  [/\\$u5d\\$/g, ']'],\n  [/\\$u7b\\$/g, '{'],\n  [/\\$u7d\\$/g, '}'],\n  [/\\$u3b\\$/g, ';'],\n  [/\\$u2b\\$/g, '+'],\n  [/\\$u22\\$/g, '\"'],\n  [/\\.\\./g, '::'],\n];\n\nfunction isHash(str) {\n  return str.length &&\n    str[0] === 'h' &&\n    str.split('').slice(1).every(char => /[0-9a-f]/i.test(char));\n}\n\n// replaces all symbols in string, returning a new string\nfunction replaceAllSymbols(str) {\n  return symbols.reduce(\n    (result, [re, char]) => result.replace(re, char),\n    str\n  );\n}\n\n// Basic rust demangle rules:\n// - starts with \"ZN | _ZN | __ZN\" and ends in \"E\"\n// - name is made up of chunks. chunks are length prefixed\n//\n// Bails early if string isn't a valid rust mangle\n//\nfunction demangle(mangled = '') {\n  const startsWith = sub => mangled.indexOf(sub) === 0;\n  const endsWith = sub => mangled.slice(-1) === sub;\n  let inner;\n\n  if (!endsWith('E')) return mangled;\n\n  if (startsWith('ZN')) inner = mangled.slice(2, -1);\n  else if (startsWith('_ZN')) inner = mangled.slice(3, -1);\n  else if (startsWith('__ZN')) inner = mangled.slice(4, -1);\n\n  if (!inner) return mangled;\n\n  const chars = inner.split('');\n  const labels = [];\n  let label = '';\n  let digits = '';\n  let length = 0;\n\n  chars.forEach((char) => {\n    // add characters to label while length marker > 0\n    if (length) {\n      label += char;\n      length--;\n\n    // otherwise, this label is complete and we start on the next\n    } else {\n      if (label) {\n        labels.push(label);\n        label = '';\n      }\n\n      // build length prefix, one digit at a time until we hit non-digit\n      if (/[0-9]/.test(char)) {\n        digits += char;\n      } else {\n        length = parseInt(digits, 10); // parse # the collected string\n        digits = '';   // clear for next time\n        label += char; // add first char to label\n        length--;      // decrement\n      }\n    }\n  });\n\n  // make sure last label is included\n  if (label) labels.push(label);\n\n  // if the last element is a hash, exclude it so the result is more readable\n  if (isHash(labels.slice(-1)[0])) labels.pop();\n\n  // replace symbol markers in labels with the actual symbols before joining\n  return labels.map(replaceAllSymbols).join('::');\n}\n\n\n// Tries to demangle an error stack on an Error object.\n// Only demangles rust right now.\n//\nexport default function demangleStack(err) {\n  // matches error stack line patterns in chrome and firefox\n  // chrome: \"at function_name (...\"\n  // firefox: \"function_name @ ...\"\n  const re = /(?:at (.+) \\()|(?:(.+)<?@)/;\n\n  // replaces matches, if found, with the demangled identifier\n  err.stack = err.stack\n    .split('\\n')\n    .map(line => line.replace(re, (_, m1, m2) => `at ${demangle(m1 || m2)} (`))\n    .join('\\n');\n\n  return err;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/demangle.js","import { parseType, types, CString } from './types';\nimport { assert, vslice } from './misc';\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\nclass AbstractStructType {\n  constructor(obj) {\n    // structs can be made with any object keys\n    // hide internal info behind the data symbol so you can still have\n    // struct fields like `.view`\n    this[DATA] = {\n      temp: {},\n      view: null,\n      free: null,\n    };\n\n    if (obj) {\n      Object.entries(obj).forEach(([key, value]) => {\n        // check for name conflicts\n        assert(key in this, `Struct missing field '${key}'`);\n        assert(key !== 'ref', 'Field `ref` is a reserved method name');\n        assert(key !== 'free', 'Field `free` is a reserved method name');\n        // this should trigger the get/setter behavior\n        this[key] = value;\n      });\n    }\n  }\n\n  ref() {\n    return (this[DATA].view) ? this[DATA].view.byteOffset : 0;\n  }\n\n  free(recursive = false) {\n    assert(!!this[DATA].free,\n      'Cant free struct, either: unallocated / already freed / sub-struct');\n\n    // frees any pointers contained in the struct\n    const freePointers = (struct) => {\n      struct.constructor.fields.forEach((field, name) => {\n        if (field.type.isPointer) struct[name].free();\n        if (field.type.isStruct) freePointers(struct[name]);\n      });\n    };\n\n    if (recursive) freePointers(this);\n\n    this[DATA].free(this.ref(), this.constructor.width);\n    this[DATA].free = null;\n    this[DATA].view = null;\n  }\n\n  static read(view, free) {\n    const StructType = this;\n\n    const struct = new StructType();\n    struct[DATA].view = view;\n    struct[DATA].free = free;\n\n    return struct;\n  }\n\n  static write(view, struct, free) {\n    const StructType = this;\n\n    StructType.fields.forEach((field, name) => {\n      const value = struct[name];\n\n      if (typeof value !== 'undefined') {\n        const fieldView = vslice(view, field.offset, field.type.width);\n        field.type.write(fieldView, value);\n      }\n    });\n\n    struct[DATA].view = view;\n    if (free) struct[DATA].free = free;\n  }\n}\n\n\n// Creates a new class that will create new struct instances\n// (this returns a constructor)\nclass Struct {\n  constructor(fields = {}, opt = {}) {\n    class StructType extends AbstractStructType {}\n\n    // keep metadata on the struct constructor itself\n    StructType.fields = new Map();\n    StructType.packed = ('packed' in opt) ? !!opt.packed : false;\n    StructType.alignment = opt.alignment || 0;\n    StructType.isStruct = true;\n\n    let offset = 0;\n\n    // preserve field insertion order with [[OwnPropertyKeys]]\n    Object.getOwnPropertyNames(fields).forEach((name) => {\n      const type = parseType(fields[name]);\n\n      if (!opt.alignment && type.alignment > StructType.alignment) {\n        StructType.alignment = type.alignment;\n      }\n\n      if (!StructType.packed && offset % type.alignment !== 0) {\n        offset += type.alignment - (offset % type.alignment);\n      }\n\n      StructType.fields.set(name, { name, offset, type });\n      offset += type.width;\n    });\n\n    StructType.width = (offset % StructType.alignment)\n      ? offset + StructType.alignment - (offset % StructType.alignment)\n      : offset;\n\n    // define getter / setter behavior for each field\n    // these will read / write each field to memory according to its type\n    StructType.fields.forEach((field, name) => {\n      Object.defineProperty(StructType.prototype, name, {\n        enumerable: true,\n\n        get() {\n          if (!this[DATA].view) {\n            return this[DATA].temp[name];\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          return field.type.read(view, this[DATA].free);\n        },\n\n        set(value) {\n          // fudging for ease of use:\n          if (typeof value === 'string' && field.type === types.string) {\n            value = new CString(value);\n          }\n\n          if (!this[DATA].view) {\n            this[DATA].temp[name] = value;\n            return;\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          field.type.write(view, value);\n        },\n      });\n    });\n\n    return StructType;\n  }\n}\n\n\nexport default Struct;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Struct.js","import { Wrapper, cwrap, ccall } from './Wrapper';\nimport Struct from './Struct';\nimport demangle from './demangle';\nimport { types, Pointer, CString, CustomType } from './types';\nimport rust from './rust';\n\nexport default {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  Pointer,\n  CustomType,\n  CString,\n  demangle,\n  rust,\n};\n\nexport {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  Pointer,\n  CustomType,\n  CString,\n  demangle,\n  rust,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { Pointer, CString } from './types';\nimport { assert } from './misc';\nimport demangle from './demangle';\n\n\nconst numbers = new Set([\n  'int8', 'int16', 'int32', 'int64',\n  'uint8', 'uint16', 'uint32', 'uint64',\n  'float', 'double',\n  'u8', 'u16', 'u32', 'u64',\n  'i8', 'i16', 'i32', 'i64',\n  'f32', 'f64',\n  'schar', 'short', 'int', 'long',\n  'char', 'uchar', 'ushort', 'uint', 'ulong',\n  'size_t',\n  'usize',\n]);\n\n\nfunction areValid(types) {\n  return types.every(type =>\n    type === null ||\n    type === undefined ||\n    type === 'void' ||\n    type === 'number' ||\n    type === 'boolean' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type === 'array' ||\n    numbers.has(type) ||\n    type.isStruct ||\n    type.isPointer);\n}\n\n\n// gets the wasm at a url and instantiates it.\n// checks if streaming instantiation is available and uses that\nfunction fetchAndInstantiate(url, imports) {\n  return fetch(url)\n    .then((resp) => {\n      if (!resp.ok) {\n        throw new Error(`Got a ${resp.status} fetching wasm @ ${url}`);\n      }\n\n      const wasm = 'application/wasm';\n      const type = resp.headers.get('content-type');\n\n      return (WebAssembly.instantiateStreaming && type === wasm)\n        ? WebAssembly.instantiateStreaming(resp, imports)\n        : resp.arrayBuffer().then(buf => WebAssembly.instantiate(buf, imports));\n    })\n    .then(result => result.instance);\n}\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('wrapper-data')\n  : '__data';\n\n\nclass Wrapper {\n  constructor(signatures, opts = {}) {\n    // Keep internal info behind the DATA symbol, try to minimize footprint so\n    // wrapped function names don't conflict with whats already here.(Like if\n    // someone had a method called \"memory()\", it would've been a problem)\n    // Same strategy with the \"__\" prefixed object methods.\n    this[DATA] = {\n      instance: null,\n      imports: null,\n      signatures: new Set(),\n      allocations: new Map(),\n      memory: opts.memory,\n      debug: !!opts.debug,\n    };\n\n    Object.entries(signatures).forEach(([fn, [returnType, argTypes = []]]) => {\n      // check for name collisions:\n      assert(fn !== 'exports', '`exports` is a reserved wrapper name');\n      assert(fn !== 'utils', '`utils` is a reserved wrapper name');\n      assert(fn !== 'imports', '`imports` is a reserved wrapper method name');\n      assert(fn !== 'fetch', '`fetch` is a reserved wrapper method name');\n      assert(fn !== 'use', '`use` is a reserved wrapper method name');\n\n      // validate arg types\n      assert(argTypes.every(arg => !!arg), `'${fn}' has undefined types`);\n      assert(areValid([returnType]), `'${fn}' has invalid types`);\n      assert(areValid(argTypes), `'${fn}' has invalid types`);\n\n      this[DATA].signatures.add({ fnName: fn, returnType, argTypes });\n    });\n\n    // exposing some methods via `.utils`\n    this.utils = {\n      readString:   this.__readString.bind(this),\n      writeString:  this.__writeString.bind(this),\n      writeArray:   this.__writeArray.bind(this),\n      readStruct:   this.__readStruct.bind(this),\n      writeStruct:  this.__readStruct.bind(this),\n      readPointer:  this.__readPointer.bind(this),\n      writePointer: this.__readPointer.bind(this),\n\n      allocate: function(value) {\n        assert('ref' in value, 'This method is for Pointer / Structs / CStrings');\n\n        (value instanceof Pointer || value instanceof CString)\n          ? this.__writePointer(value)\n          : this.__writeStruct(value);\n      }.bind(this),\n\n      free: function(value) {\n        ('ref' in value)\n          ? this.__free(value.ref())\n          : this.__free(value);\n      }.bind(this),\n    };\n\n    this.exports = null;\n    this.__free = this.__free.bind(this); // convenience bind\n  }\n\n  // takes an import object or a function what will produce a import object\n  imports(arg, defaults = true) {\n    const wrap = (...args) => {\n      // function to wrap is always the last argument\n      const fn = args.pop();\n      // two argument formats (this might be a bad idea):\n      //   * with return type: wrap([returnType, [...argTypes]], fn)\n      //   * no return type: wrap(arg1, arg2, ..., fn)\n      //\n      const types = (Array.isArray(args[0])) ? args[0] : [null, args];\n      // detructure into appropriate vars\n      const [returnType, argTypes = []] = types;\n\n      assert(areValid(argTypes), `Import has invalid types: ${argTypes}`);\n      assert(areValid([returnType]), `Import has invalid types: ${returnType}`);\n\n      return (...raw) => {\n        const value = fn(...raw.map((r, i) => this.__out(r, argTypes[i])));\n\n        if (returnType && returnType !== 'void') {\n          return this.__in(value, returnType);\n        }\n      };\n    };\n\n    const env = {\n      print:  wrap('string', str => console.log(str)),\n      eprint: wrap('string', str => console.error(str)),\n\n      trace:  wrap('string', (str) => {\n        throw new Error(str);\n      }),\n\n      _abort(errCode) {\n        throw new Error(`wasm aborting: ${errCode}`);\n      },\n\n      _exit(exitCode) {\n        if (exitCode) throw new Error(`wasm exit error: ${exitCode}`);\n      },\n\n      _grow() {},\n    };\n\n    const obj = (typeof arg === 'function')\n      ? arg(wrap)\n      : arg;\n\n    if (defaults) obj.env = Object.assign(env, obj.env);\n    this[DATA].imports = obj;\n\n    return obj;\n  }\n\n  fetch(url) {\n    const imports = this[DATA].imports || this.imports({});\n\n    return fetchAndInstantiate(url, imports).then((instance) => {\n      this.__link(instance);\n      return this;\n    });\n  }\n\n  use(instance) {\n    assert(instance instanceof WebAssembly.Instance,\n      '.use(instance) requires a WebAssembly.Instance');\n\n    this.__link(instance);\n    return this;\n  }\n\n  __link(instance) {\n    const memory = this[DATA].memory ||\n                   instance.exports.memory ||\n                   (this[DATA].imports.env && this[DATA].imports.env.memory);\n\n    assert(!!memory, '' +\n      'Wrapper needs access to your WebAssemmbly memory. It looks for this in' +\n      'either your `imports.env.memory` or `exports.env.memory`. If you don\\'t' +\n      'use either, you need to add it in the options with `new Wrapper`');\n\n    this.exports = instance.exports;\n    this[DATA].instance = instance;\n    this[DATA].memory = memory;\n\n    this[DATA].signatures.forEach(({ fnName, returnType, argTypes }) => {\n      const fn = this.exports[fnName];\n      assert(!!fn, `Fn '${fnName}' missing from wasm exports`);\n\n      this[fnName] = this.__wrap(fn, argTypes, returnType);\n    });\n  }\n\n  __wrap(fn, argTypes, returnType) {\n    return function(...args) {\n      const stack = [];\n      const ffi_args = args.map((arg, i) => this.__in(arg, argTypes[i], stack));\n\n      let value;\n\n      try {\n        value = fn(...ffi_args);\n      } catch (err) {\n        throw demangle(err);\n      }\n\n      stack.forEach(ptr => this.__free(ptr));\n\n      if (returnType && returnType !== 'void') {\n        return this.__out(value, returnType);\n      }\n    };\n  }\n\n  // wrap a variable heading into a wasm function\n  __in(value, type, stack) {\n    assert(!!type, 'No arg type was specified for function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__writeString(value, stack);\n    if (type === 'array') return this.__writeArray(value, stack);\n    if (type.isStruct) return this.__writeStruct(value);\n    if (type.isPointer) return this.__writePointer(value);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  // wrap a variable heading out of a wasm function\n  __out(value, type) {\n    assert(!!type, 'No arg type was specified for function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__readString(value);\n    if (type.isStruct) return this.__readStruct(value, type);\n    if (type.isPointer) return this.__readPointer(value, type);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  __allocate(size) {\n    assert(!!this.exports.allocate && !!this.exports.deallocate,\n      \"Missing allocate/deallocate fns in wasm exports, can't allocate memory\");\n\n    const ptr = this.exports.allocate(size);\n    assert(!!ptr, 'allocate failed');\n\n    if (this[DATA].debug) console.log('Alloc: %s (size=%s)', ptr, size);\n    this[DATA].allocations.set(ptr, size);\n\n    return ptr;\n  }\n\n  __free(ptr, optSize) {\n    const size = optSize || this[DATA].allocations.get(ptr);\n    if (this[DATA].debug) console.log('Free: %s (size=%s)', ptr, size);\n\n    this.exports.deallocate(ptr, size);\n    this[DATA].allocations.delete(ptr);\n  }\n\n  __view(start, length) {\n    return new DataView(this[DATA].memory.buffer, start, length);\n  }\n\n  __readString(ptr) {\n    const view = new Uint8Array(this[DATA].memory.buffer);\n\n    // find end of string (null byte)\n    let end = ptr;\n    while (view[end]) ++end;\n\n    // subarray uses same underlying ArrayBuffer\n    const buf = new Uint8Array(view.subarray(ptr, end));\n    const str = (new TextDecoder()).decode(buf);\n\n    return str;\n  }\n\n  __writeString(str, stack) {\n    const buf = (new TextEncoder()).encode(str);\n    const len = buf.byteLength + 1;\n\n    const ptr = this.__allocate(len);\n    if (stack) stack.push(ptr);\n\n    const view = new Uint8Array(this[DATA].memory.buffer);\n    view.set(buf, ptr);\n    view[ptr + len - 1] = 0;\n\n    return ptr;\n  }\n\n  __writeArray(arr, stack) {\n    assert(arr instanceof ArrayBuffer || ArrayBuffer.isView(arr),\n      'Argument must be an `ArrayBuffer` or a `DataView` (like `Uint8Array`)');\n\n    const buf = (ArrayBuffer.isView(arr))\n      ? new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength)\n      : new Uint8Array(arr);\n\n    const ptr = this.__allocate(buf.byteLength);\n    if (stack) stack.push(ptr);\n\n    const view = new Uint8Array(this[DATA].memory.buffer);\n    view.set(buf, ptr);\n\n    return ptr;\n  }\n\n  __readStruct(ptr, StructType) {\n    assert(!!StructType, 'No struct StructType given');\n\n    const view = this.__view(ptr, StructType.width);\n    const struct = StructType.read(view, this.__free);\n\n    return struct;\n  }\n\n  __writeStruct(struct) {\n    // if struct has already been allocated:\n    if (struct.ref()) return struct.ref();\n\n    const StructType = struct.constructor;\n    const ptr = this.__allocate(StructType.width);\n    const view = this.__view(ptr, StructType.width);\n\n    const allocPointers = (sub) => {\n      sub.constructor.fields.forEach((field, name) => {\n        if (field.type.isStruct && sub[name]) {\n          allocPointers(sub[name]);\n        }\n\n        if (field.type.isPointer && sub[name]) {\n          this.__writePointer(sub[name]);\n        }\n      });\n    };\n\n    allocPointers(struct);\n    StructType.write(view, struct, this.__free);\n\n    return ptr;\n  }\n\n  __readPointer(ptr, ptrType) {\n    assert(!!ptrType, 'No pointer type given');\n\n    // get the size of what the pointer points to\n    const view = this.__view(ptr, ptrType.type.width);\n\n    // handle pointer of a pointer cases (structs are pointers too here)\n    if (ptrType.type.isStruct || ptrType.type.isPointer) {\n      return ptrType.read(view, this.__free);\n    }\n\n    const pointer = new Pointer(ptrType.type);\n    pointer.attach(view, this.__free);\n\n    return pointer;\n  }\n\n  __writePointer(pointer) {\n    if (pointer.ref()) return pointer.ref();\n\n    // allocate space for what the pointer points to\n    const addr = this.__allocate(pointer.type.width);\n    const view = this.__view(addr, pointer.type.width);\n\n    // attach wasm memory to pointer and write the pointed-to data\n    pointer.attach(view, this.__free);\n\n    return addr;\n  }\n}\n\n\nfunction cwrap(instance, fnName, returnType = null, argTypes = []) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.cwrap() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].bind(wrapper);\n}\n\nfunction ccall(instance, fnName, returnType = null, argTypes = [], ...args) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.ccall() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].call(wrapper, ...args);\n}\n\n\nexport { Wrapper, cwrap, ccall };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Wrapper.js","import Struct from './Struct';\nimport { types, parseType, Pointer } from './types';\nimport { assert, vslice } from './misc';\n\n\n// get the symbol for struct-data since we need access here\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\n// helper fn, overrides free to be free(true) by default\nfunction extend(StructType) {\n  class RustType extends StructType {\n    free() {\n      super.free(true);\n    }\n  }\n\n  Object.assign(RustType, StructType);\n  return RustType;\n}\n\n\nfunction RustTuple(...tupleTypes) {\n  const fields = {};\n\n  tupleTypes.forEach((type, i) => {\n    fields[i] = parseType(type);\n  });\n\n  return new Struct(fields);\n}\n\n\nfunction RustVector(typedef) {\n  const type = parseType(typedef);\n\n  const Vector = extend(new Struct({\n    ptr: types.pointer(type),\n    cap: 'usize',\n    len: 'usize',\n    /* values */\n  }));\n\n  Object.defineProperty(Vector.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const arrayType = parseType([type, this.len]);\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, this[DATA].free);\n    },\n\n    set(values) {\n      const len = values.length;\n\n      this.ptr = new Pointer([type, len], values);\n      this.len = len;\n      this.cap = len;\n    },\n  });\n\n  return Vector;\n}\n\n\nfunction RustSlice(typedef) {\n  const type = parseType(typedef);\n\n  const Slice = extend(new Struct({\n    ptr: types.pointer(type),\n    len: 'usize',\n    /* values */\n  }));\n\n  Object.defineProperty(Slice.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const arrayType = parseType([type, this.len]);\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, this[DATA].free);\n    },\n\n    set(values) {\n      const len = values.length;\n\n      this.ptr = new Pointer([type, len], values);\n      this.len = len;\n    },\n  });\n\n  return Slice;\n}\n\n\nfunction RustString() {\n  const RString = extend(new Struct({\n    ptr: types.pointer('u8'),\n    cap: 'usize',\n    len: 'usize',\n    /* value */\n  }));\n\n  Object.defineProperty(RString.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), this.len);\n\n      return (new TextDecoder()).decode(view);\n    },\n\n    set(str) {\n      const buf = (new TextEncoder()).encode(str);\n      const len = buf.length;\n\n      this.ptr = new Pointer(['u8', len], buf);\n      this.len = len;\n      this.cap = len;\n    },\n  });\n\n  RString.prototype.toString = function() {\n    return this.value;\n  };\n\n  return RString;\n}\n\n\nfunction RustStr() {\n  const RStr = extend(new Struct({\n    ptr: types.pointer('u8'),\n    len: 'usize',\n    /* value */\n  }));\n\n  Object.defineProperty(RStr.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), this.len);\n\n      return (new TextDecoder()).decode(view);\n    },\n\n    set(str) {\n      const buf = (new TextEncoder()).encode(str);\n      const len = buf.length;\n\n      this.ptr = new Pointer(['u8', len], buf);\n      this.len = len;\n    },\n  });\n\n  RStr.prototype.toString = function() {\n    return this.value;\n  };\n\n  return RStr;\n}\n\n\nfunction RustOption(typedef, isNonNullable = false, tagSize) {\n  const type = parseType(typedef);\n  let discriminant;\n\n  if (tagSize) discriminant = types[`uint${tagSize * 8}`];\n  else if (type.alignment === 1) discriminant = 'uint8';\n  else if (type.alignment === 2) discriminant = 'uint16';\n  else discriminant = 'uint32';\n\n  const fields = (isNonNullable)\n    ? { value: type }\n    : { discriminant, value: type };\n\n  const Option = new Struct(fields);\n\n  Object.assign(Option.prototype, {\n    isSome() {\n      return ('discriminant' in fields) ? !!this.discriminant : !!this.value;\n    },\n\n    isNone() {\n      return !this.isSome();\n    },\n\n    expect(msg) {\n      if (!this.isSome()) throw new Error(msg);\n      return this.value;\n    },\n\n    unwrap() {\n      if (!this.isSome()) throw new Error('Error unwrapping none');\n      return this.value;\n    },\n\n    unwrapOr(defaultValue) {\n      return (this.isSome()) ? this.value : defaultValue;\n    },\n\n    unwrapOrElse(fn) {\n      return (this.isSome()) ? this.value : fn();\n    },\n  });\n\n  return Option;\n}\n\n\nfunction RustEnum(obj, tagSize = 4) {\n  const variants = Object.getOwnPropertyNames(obj);\n  const vtypes = variants.map(name => parseType(obj[name]));\n  const discriminant = types[`uint${tagSize * 8}`];\n\n  const StructType = new Struct({\n    discriminant,\n    /* value */\n  });\n\n  class Enum extends StructType {\n    constructor(variant) {\n      super();\n      if (variant) this._set(variant);\n    }\n\n    _set(variant) {\n      assert(Object.keys(variant).length === 1, 'Enum value must be a variant');\n\n      const [name, value] = Object.entries(variant)[0];\n\n      this.discriminant = variants.indexOf(name);\n      this.value = value;\n    }\n\n    tag() {\n      const tag = this.discriminant;\n      assert(tag <= variants.length, 'Enum discriminant > than # of variants');\n      return tag;\n    }\n\n    free(recursive = false) {\n      const type = vtypes[this.tag()];\n\n      if (recursive && type.isPointer || type.isStruct) {\n        this.value.free(recursive);\n      }\n\n      this[DATA].free(this.ref(), Enum.width);\n      this[DATA].free = null;\n      this[DATA].view = null;\n    }\n\n    name() {\n      return variants[this.tag()];\n    }\n\n    is(name) {\n      return (variants.indexOf(name) === this.tag());\n    }\n\n    match(arms) {\n      const name = variants[this.tag()];\n      const val = this.value;\n\n      if (name in arms) {\n        return (typeof arms[name] === 'function') ? arms[name](val) : arms[name];\n      }\n\n      if ('_' in arms) {\n        return (typeof arms._ === 'function') ? arms._(val) : arms._;\n      }\n    }\n\n    static write(view, struct, free) {\n      const tag = struct.tag();\n      const type = vtypes[tag];\n      const value = (struct.ref()) ? struct.value : struct[DATA].temp.value;\n\n      const field_1 = vslice(view, 0, discriminant.width);\n      discriminant.write(field_1, tag);\n\n      const field_2 = vslice(view, discriminant.width, type.width);\n      type.write(field_2, value);\n\n      struct[DATA].view = view;\n      if (free) struct[DATA].free = free;\n    }\n  }\n\n  Object.defineProperty(Enum.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const addr = this.ref() + discriminant.width;\n      const memory = this[DATA].view.buffer;\n\n      const type = vtypes[this.tag()];\n      const view = new DataView(memory, addr, type.width);\n\n      return type.read(view, this[DATA].free);\n    },\n\n    set(value) {\n      this[DATA].temp.value = value;\n    },\n  });\n\n  Object.assign(Enum, StructType);\n\n  const max = arr => arr.reduce((acc, i) => (i > acc) ? i : acc, 0);\n  const width = discriminant.width + max(vtypes.map(t => t.width));\n  const align = max([...vtypes.map(t => t.alignment), discriminant.alignment]);\n\n  Enum.width = (width % align)\n    ? width + align - (width % align)\n    : width;\n\n  return Enum;\n}\n\n\nconst rust = {\n  tuple: RustTuple,\n  Tuple: (type, values) => new (RustTuple(...type))([...values]),\n\n  vector: RustVector,\n  Vector: (type, values) => new (RustVector(type))({ values }),\n\n  slice: RustSlice,\n  Slice: (type, values) => new (RustSlice(type))({ values }),\n\n  string: RustString(),\n  String: str => new (rust.string)({ value: str }),\n\n  str: RustStr(),\n  Str: str => new (rust.str)({ value: str }),\n\n  option: RustOption,\n  Option: (type, value, ...opts) => new (RustOption(type, ...opts))({\n    value,\n    discriminant: (typeof value === 'undefined') ? 0 : 1,\n  }),\n\n  Some: (...args) => rust.Option(...args),\n  None: (type, ...opts) => rust.Option(type, undefined, ...opts),\n\n  enum: RustEnum,\n};\n\nexport default rust;\n\n\n\n// WEBPACK FOOTER //\n// ./src/rust.js"],"sourceRoot":""}