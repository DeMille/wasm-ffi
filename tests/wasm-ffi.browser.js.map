{"version":3,"sources":["webpack:///webpack/bootstrap 5ff1256375d42600b658","webpack:///./src/types.js","webpack:///./src/encoding.js","webpack:///./src/misc.js","webpack:///./src/demangle.js","webpack:///./src/Struct.js","webpack:///./src/index.js","webpack:///./src/Wrapper.js","webpack:///./src/rust.js"],"names":["CustomType","size","opts","isNaN","width","alignment","read","write","view","value","ArrayBuffer","isView","buf","Uint8Array","buffer","byteOffset","byteLength","uint8","set","Signed","get","Unsigned","types","void","int8","int16","int32","uint16","uint32","int64","uint64","float","getFloat32","setFloat32","double","getFloat64","setFloat64","bool","getInt8","setInt8","Pointer","type","parseType","_free","_temp","free","ref","pointer","typedef","isPointer","addr","getUint32","DataView","setUint32","CString","encode","memory","end","subarray","str","decode","deref","string","length","data","ArrayType","arr","i","subview","push","values","forEach","aliases","u8","u16","u32","u64","i8","i16","i32","i64","f32","f64","char","uchar","schar","short","ushort","int","uint","long","ulong","longlong","ulonglong","size_t","usize","parseTypeString","name","toLowerCase","Error","Array","isArray","errMsg","encodeUTF8","codePoint","leadSurrogate","units","Infinity","bytes","charCodeAt","from","decodeUTF8","start","pts","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","MAX","fromCharCode","call","String","j","slice","EncoderPolyfill","DecoderPolyfill","Encoder","TextEncoder","Decoder","TextDecoder","assert","vslice","condition","args","msg","strings","map","JSON","stringify","arg","e","split","part","pop","demangleStack","symbols","isHash","every","test","replaceAllSymbols","reduce","result","re","replace","demangle","mangled","startsWith","indexOf","sub","endsWith","inner","chars","labels","label","digits","parseInt","join","err","stack","line","_","m1","m2","DATA","Symbol","for","AbstractStructType","obj","temp","Object","entries","key","recursive","freePointers","struct","constructor","fields","field","isStruct","StructType","fieldView","offset","Struct","opt","Map","packed","getOwnPropertyNames","defineProperty","prototype","enumerable","_encodeUTF8","_decodeUTF8","Wrapper","cwrap","ccall","rust","numbers","Set","areValid","undefined","has","fs","fetch_polyfill","file","Promise","resolve","reject","eval","readFile","arrayBuffer","ok","fetchFn","fetch","fetchAndInstantiate","url","imports","then","resp","status","wasm","headers","WebAssembly","instantiateStreaming","instantiate","instance","signatures","allocations","debug","fn","returnType","argTypes","add","fnName","utils","readString","__readString","bind","writeString","__writeString","writeArray","__writeArray","readStruct","__readStruct","writeStruct","readPointer","__readPointer","writePointer","allocate","__writePointer","__writeStruct","__free","exports","defaults","wrap","raw","r","__out","__in","env","print","console","log","eprint","error","trace","_abort","errCode","_exit","exitCode","_grow","assign","__link","Instance","__wrap","ffi_args","ptr","deallocate","optSize","delete","len","__allocate","__view","allocPointers","ptrType","attach","wrapper","use","extend","RustType","RustTuple","tupleTypes","RustVector","Vector","cap","arrayType","RustSlice","Slice","RustString","RString","toString","RustStr","RStr","RustOption","isNonNullable","tagSize","discriminant","Option","isSome","isNone","expect","unwrap","unwrapOr","defaultValue","unwrapOrElse","RustEnum","variants","vtypes","Enum","variant","_set","keys","tag","arms","val","field_1","field_2","max","acc","t","align","tuple","Tuple","ctor","vector","Str","option","Some","None","enum"],"mappings":"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","file":"wasm-ffi.browser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5ff1256375d42600b658","import { Encoder, Decoder } from './encoding';\nimport { assert, vslice } from './misc';\n\n\n// Makes a type of a given size.\n// Optional read / write methods, just gives a DataView by default.\nclass CustomType {\n  constructor(size, opts = {}) {\n    assert(!isNaN(size), 'Type size must be a number, given: %s', size);\n\n    this.width = size;\n    this.alignment = ('alignment' in opts) ? opts.alignment : size;\n\n    if (opts.read) this.read = opts.read;\n    if (opts.write) this.write = opts.write;\n  }\n\n  read(view) {\n    return view;\n  }\n\n  write(view, value) {\n    assert(value instanceof ArrayBuffer || ArrayBuffer.isView(value),\n      'Value must be an `ArrayBuffer` or a `DataView` (like `Uint8Array`)');\n\n    const buf = (ArrayBuffer.isView(value))\n      ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength)\n      : new Uint8Array(value);\n\n    const uint8 = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n\n    uint8.set(buf);\n  }\n}\n\n\nclass Signed {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getInt${width * 8}`;\n    const set = `setInt${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nclass Unsigned {\n  constructor(width) {\n    this.width = width;\n    this.alignment = width;\n\n    const get = `getUint${width * 8}`;\n    const set = `setUint${width * 8}`;\n\n    this.read = view => view[get](0, true /* little-endian */);\n    this.write = (view, value) => view[set](0, value, true /* little-endian */);\n  }\n}\n\n\nconst types = {};\n\ntypes.void = {\n  width: 0,\n  alignment: 0,\n  read: () => null,\n  write: () => {},\n};\n\ntypes.int8 = new Signed(1);\ntypes.int16 = new Signed(2);\ntypes.int32 = new Signed(4);\ntypes.uint8 = new Unsigned(1);\ntypes.uint16 = new Unsigned(2);\ntypes.uint32 = new Unsigned(4);\n\ntypes.int64 = new CustomType(8);\ntypes.uint64 = new CustomType(8);\n\ntypes.float = {\n  width: 4,\n  alignment: 4,\n\n  read(view) {\n    return view.getFloat32(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat32(0, value, true /* little-endian */);\n  },\n};\n\ntypes.double = {\n  width: 8,\n  alignment: 8,\n\n  read(view) {\n    return view.getFloat64(0, true /* little-endian */);\n  },\n\n  write(view, value) {\n    view.setFloat64(0, value, true /* little-endian */);\n  },\n};\n\ntypes.bool = {\n  width: 1,\n  alignment: 1,\n\n  read(view) {\n    return !!view.getInt8(0);\n  },\n\n  write(view, value) {\n    view.setInt8(0, (!!value) ? 1 : 0);\n  },\n};\n\n\n// A pointer to some other data type in memory\nclass Pointer {\n  constructor(type, value) {\n    this.type = parseType(type);\n    this.view = null;\n    this._free = null;\n    this._temp = value;\n  }\n\n  attach(view, free) {\n    this.view = view;\n    this._free = free;\n\n    if (this._temp) this.set(this._temp);\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated pointer');\n    return this.type.read(this.view, this._free);\n  }\n\n  set(value) {\n    if (this.view) {\n      this.type.write(this.view, value, this._free);\n    } else {\n      this._temp = value;\n    }\n  }\n\n  free() {\n    assert(this.view, 'Cant free pointer: unallocated / already freed');\n\n    this._free(this.ref(), this.type.width);\n    this._free = null;\n    this.view = null;\n  }\n}\n\ntypes.pointer = function(typedef) {\n  const type = parseType(typedef);\n\n  return {\n    type,\n    width: 4,\n    alignment: 4,\n    isPointer: true,\n\n    read(view, free) {\n      const addr = view.getUint32(0, true /* little-endian */);\n\n      const pointer = new Pointer(type);\n      pointer.view = new DataView(view.buffer, addr, type.width);\n      pointer._free = free;\n\n      return pointer;\n    },\n\n    write(view, value) {\n      assert(value instanceof Pointer, `Trying to write ${value} as a pointer`);\n      assert(value.ref(), 'Cant write pointer, hasnt been allocated yet');\n      view.setUint32(0, value.ref(), true /* little-endian */);\n    },\n  };\n};\n\n\n// A pointer to a null-terminated string\nclass CString {\n  constructor(value, free) {\n    this.type = {\n      isPointer: true,\n      width: null,\n    };\n    this.view = null;\n    this._temp = null;\n    this._free = null;\n\n    if (typeof value === 'string') {\n      this._temp = (new Encoder()).encode(value);\n      this.type.width = this._temp.byteLength + 1;\n    }\n\n    if (value instanceof DataView) {\n      this.view = value;\n      this._free = free;\n      this.type.width = value.byteLength;\n    }\n  }\n\n  attach(view, free) {\n    this.view = view;\n    this._free = free;\n\n    if (this._temp) {\n      const memory = new Uint8Array(view.buffer);\n\n      memory.set(this._temp, view.byteOffset);\n      memory[view.byteOffset + this.type.width - 1] = 0;\n    }\n  }\n\n  ref() {\n    return (this.view) ? this.view.byteOffset : 0;\n  }\n\n  deref() {\n    assert(this.view, 'Trying to deref an unallocated CString');\n\n    const memory = new Uint8Array(this.view.buffer);\n    const addr = this.view.byteOffset;\n    const end = addr + this.type.width - 1;\n\n    // `subarray` uses the same underlying ArrayBuffer\n    const buf = new Uint8Array(memory.subarray(addr, end));\n    const str = (new Decoder()).decode(buf);\n\n    return str;\n  }\n\n  free() {\n    assert(!!this.view, 'Cant free cstring: unallocated / already freed');\n\n    this._free(this.ref(), this.type.width);\n    this._free = null;\n    this.view = null;\n  }\n\n  valueOf() {\n    return this.deref();\n  }\n\n  toString() {\n    return this.deref();\n  }\n}\n\ntypes.string = {\n  width: 4,\n  alignment: 4,\n  isPointer: true,\n\n  read(view, free) {\n    const memory = new Uint8Array(view.buffer);\n    const addr = view.getUint32(0, true /* little-endian */);\n    let end = addr;\n\n    // find null byte\n    while (memory[end]) ++end;\n\n    const length = end - addr + 1;\n    const data = new DataView(view.buffer, addr, length);\n\n    return new CString(data, free);\n  },\n\n  write(view, value) {\n    assert(value instanceof CString, 'value must be a `CString`');\n    assert(value.ref(), 'Cant write CString, hasnt been allocated yet');\n    view.setUint32(0, value.ref(), true /* little-endian */);\n  },\n};\n\n\n// An array (of known size) of sub-types.\nclass ArrayType {\n  constructor(type, length) {\n    this.type = type;\n    this.length = length;\n\n    this.width = type.width * length;\n    this.alignment = type.alignment;\n  }\n\n  read(view, free) {\n    const arr = [];\n\n    for (let i = 0; i <= this.length - 1; i++) {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      arr.push(this.type.read(subview, free));\n    }\n\n    return arr;\n  }\n\n  write(view, values) {\n    assert(values.length === this.length,\n      'Values length does not match struct array length');\n\n    values.forEach((value, i) => {\n      const subview = vslice(view, i * this.type.width, this.type.width);\n      this.type.write(subview, value);\n    });\n  }\n}\n\n\n// Maps other names to base types\n//\n// Some questionable decisions:\n//  - char = uint8 (I mean, what do you do, really)\n//  - long = int32 (windows=32, linux=64, wasm is 32bit right now, so...)\n//\nconst aliases = {\n  u8: types.uint8,\n  u16: types.uint16,\n  u32: types.uint32,\n  u64: types.uint64,\n  i8: types.int8,\n  i16: types.int16,\n  i32: types.int32,\n  i64: types.int64,\n  f32: types.float,\n  f64: types.double,\n  char: types.uint8,\n  uchar: types.uint8,\n  schar: types.int8,\n  short: types.int16,\n  ushort: types.uint16,\n  int: types.int32,\n  uint: types.uint32,\n  long: types.int32,\n  ulong: types.uint32,\n  longlong: types.uint64,\n  ulonglong: types.uint64,\n  size_t: types.uint32,\n  usize: types.uint32,\n};\n\n\nfunction parseTypeString(str) {\n  const name = str.toLowerCase();\n\n  if (name in types) return types[name];\n  if (name in aliases) return aliases[name];\n\n  throw new Error(`Parsing unknown type '${str}'`);\n}\n\n\n// parse a type from some type definition.\n// may be a string, an actual type, or an array of types\nfunction parseType(typedef) {\n  if (typeof typedef === 'string') {\n    return parseTypeString(typedef);\n  }\n\n  if (Array.isArray(typedef)) {\n    assert(typedef.length === 2,\n      'Array type needs 2 arguments: [type, length], given: \\n%s', typedef);\n\n    const type = parseType(typedef[0]);\n    const length = typedef[1];\n\n    return new ArrayType(type, length);\n  }\n\n  // make sure its an ok type interface\n  const errMsg = \"Given argument type isn't a proper 'type' interface: \\n%s\";\n  assert('width' in typedef, errMsg, typedef);\n  assert('alignment' in typedef, errMsg, typedef);\n  assert('read' in typedef, errMsg, typedef);\n  assert('write' in typedef, errMsg, typedef);\n\n  return typedef;\n}\n\n\nexport { types, CustomType, Pointer, CString, parseType };\n\n\n\n// WEBPACK FOOTER //\n// ./src/types.js","// utf8 decode/encode adapted from the buffer module\n// @ github.com/feross/buffer\n//\nfunction encodeUTF8(str) {\n  let codePoint;\n  let leadSurrogate = null;\n  let units = Infinity;\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    codePoint = str.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n\n        } else if (i + 1 === str.length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      );\n\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return Uint8Array.from(bytes);\n}\n\n\nfunction decodeUTF8(buf) {\n  const start = 0; // view.byteOffset;\n  const end = buf.length;\n\n  const pts = [];\n  let i = start;\n\n  while (i < end) {\n    const firstByte = buf[i];\n    let codePoint = null;\n\n    let bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1;\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        default:\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      pts.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    pts.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n  // the lowest limit is Chrome, with 0x10000 args.\n  // We go 1 magnitude less, for safety\n  const MAX = 0x1000;\n\n  if (pts.length <= MAX) {\n    return String.fromCharCode.call(String, ...pts); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let str = '';\n  let j = 0;\n\n  while (j < pts.length) {\n    str += String.fromCharCode.call(String, ...pts.slice(j, j += MAX));\n  }\n\n  return str;\n}\n\n\nclass EncoderPolyfill {\n  encode(str) {\n    return encodeUTF8(str);\n  }\n}\n\nclass DecoderPolyfill {\n  decode(view) {\n    return decodeUTF8(view);\n  }\n}\n\n\nconst Encoder = (typeof TextEncoder !== 'undefined')\n  ? TextEncoder\n  : EncoderPolyfill;\n\nconst Decoder = (typeof TextDecoder !== 'undefined')\n  ? TextDecoder\n  : DecoderPolyfill;\n\n\nexport { Encoder, Decoder, encodeUTF8, decodeUTF8 };\n\n\n\n// WEBPACK FOOTER //\n// ./src/encoding.js","// simple assert, throws if assertion fails\n// also matches args to %s formatters\nexport function assert(condition, errMsg, ...args) {\n  if (condition) return;\n  if (!args || !args.length) throw new Error(errMsg);\n\n  let msg = '';\n  let strings;\n\n  try {\n    strings = args.map(arg => JSON.stringify(arg, null, 2));\n  } catch (e) {\n    throw new Error(errMsg);\n  }\n\n  errMsg.split('%s').forEach((part) => {\n    msg += part;\n    if (strings.length) msg += strings.pop();\n  });\n\n  throw new Error(msg);\n}\n\n// takes a subslice of a DataView\nexport function vslice(view, start, length) {\n  return new DataView(view.buffer, view.byteOffset + start, length);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/misc.js","// Rust demangle logic adpated from Alex Crichton's ructc-demangle:\n// http://alexcrichton.com/rustc-demangle/src/rustc_demangle/lib.rs.html\nconst symbols = [\n  [/^_\\$/, '$'],\n  [/\\$C\\$/g, ','],\n  [/\\$SP\\$/g, '@'],\n  [/\\$BP\\$/g, '*'],\n  [/\\$RF\\$/g, '&'],\n  [/\\$LT\\$/g, '<'],\n  [/\\$GT\\$/g, '>'],\n  [/\\$LP\\$/g, '('],\n  [/\\$RP\\$/g, ')'],\n  [/\\$u7e\\$/g, '~'],\n  [/\\$u20\\$/g, ' '],\n  [/\\$u27\\$/g, \"'\"],\n  [/\\$u5b\\$/g, '['],\n  [/\\$u5d\\$/g, ']'],\n  [/\\$u7b\\$/g, '{'],\n  [/\\$u7d\\$/g, '}'],\n  [/\\$u3b\\$/g, ';'],\n  [/\\$u2b\\$/g, '+'],\n  [/\\$u22\\$/g, '\"'],\n  [/\\.\\./g, '::'],\n];\n\nfunction isHash(str) {\n  return str.length &&\n    str[0] === 'h' &&\n    str.split('').slice(1).every(char => /[0-9a-f]/i.test(char));\n}\n\n// replaces all symbols in string, returning a new string\nfunction replaceAllSymbols(str) {\n  return symbols.reduce(\n    (result, [re, char]) => result.replace(re, char),\n    str\n  );\n}\n\n// Basic rust demangle rules:\n// - starts with \"ZN | _ZN | __ZN\" and ends in \"E\"\n// - name is made up of chunks. chunks are length prefixed\n//\n// Bails early if string isn't a valid rust mangle\n//\nfunction demangle(mangled = '') {\n  const startsWith = sub => mangled.indexOf(sub) === 0;\n  const endsWith = sub => mangled.slice(-1) === sub;\n  let inner;\n\n  if (!endsWith('E')) return mangled;\n\n  if (startsWith('ZN')) inner = mangled.slice(2, -1);\n  else if (startsWith('_ZN')) inner = mangled.slice(3, -1);\n  else if (startsWith('__ZN')) inner = mangled.slice(4, -1);\n\n  if (!inner) return mangled;\n\n  const chars = inner.split('');\n  const labels = [];\n  let label = '';\n  let digits = '';\n  let length = 0;\n\n  chars.forEach((char) => {\n    // add characters to label while length marker > 0\n    if (length) {\n      label += char;\n      length--;\n\n    // otherwise, this label is complete and we start on the next\n    } else {\n      if (label) {\n        labels.push(label);\n        label = '';\n      }\n\n      // build length prefix, one digit at a time until we hit non-digit\n      if (/[0-9]/.test(char)) {\n        digits += char;\n      } else {\n        length = parseInt(digits, 10); // parse # the collected string\n        digits = '';   // clear for next time\n        label += char; // add first char to label\n        length--;      // decrement\n      }\n    }\n  });\n\n  // make sure last label is included\n  if (label) labels.push(label);\n\n  // if the last element is a hash, exclude it so the result is more readable\n  if (isHash(labels.slice(-1)[0])) labels.pop();\n\n  // replace symbol markers in labels with the actual symbols before joining\n  return labels.map(replaceAllSymbols).join('::');\n}\n\n\n// Tries to demangle an error stack on an Error object.\n// Only demangles rust right now.\n//\nexport default function demangleStack(err) {\n  // matches error stack line patterns in chrome and firefox\n  // chrome: \"at function_name (...\"\n  // firefox: \"function_name @ ...\"\n  const re = /(?:at (.+) \\()|(?:(.+)<?@)/;\n\n  // replaces matches, if found, with the demangled identifier\n  err.stack = err.stack\n    .split('\\n')\n    .map(line => line.replace(re, (_, m1, m2) => `at ${demangle(m1 || m2)} (`))\n    .join('\\n');\n\n  return err;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/demangle.js","import { parseType, types, CString } from './types';\nimport { assert, vslice } from './misc';\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\nclass AbstractStructType {\n  constructor(obj) {\n    // structs can be made with any object keys\n    // hide internal info behind the data symbol so you can still have\n    // struct fields like `.view`\n    this[DATA] = {\n      temp: {},\n      view: null,\n      free: null,\n    };\n\n    if (obj) {\n      Object.entries(obj).forEach(([key, value]) => {\n        // check for name conflicts\n        assert(key in this, `Struct missing field '${key}'`);\n        assert(key !== 'ref', 'Field `ref` is a reserved method name');\n        assert(key !== 'free', 'Field `free` is a reserved method name');\n        // this should trigger the get/setter behavior\n        this[key] = value;\n      });\n    }\n  }\n\n  ref() {\n    return (this[DATA].view) ? this[DATA].view.byteOffset : 0;\n  }\n\n  free(recursive = false) {\n    assert(!!this[DATA].free,\n      'Cant free struct, either: unallocated / already freed / sub-struct');\n\n    // frees any pointers contained in the struct\n    const freePointers = (struct) => {\n      struct.constructor.fields.forEach((field, name) => {\n        if (field.type.isPointer) struct[name].free();\n        if (field.type.isStruct) freePointers(struct[name]);\n      });\n    };\n\n    if (recursive) freePointers(this);\n\n    this[DATA].free(this.ref(), this.constructor.width);\n    this[DATA].free = null;\n    this[DATA].view = null;\n  }\n\n  static read(view, free) {\n    const StructType = this;\n\n    const struct = new StructType();\n    struct[DATA].view = view;\n    struct[DATA].free = free;\n\n    return struct;\n  }\n\n  static write(view, struct, free) {\n    const StructType = this;\n\n    StructType.fields.forEach((field, name) => {\n      const value = struct[name];\n\n      if (typeof value !== 'undefined') {\n        const fieldView = vslice(view, field.offset, field.type.width);\n        field.type.write(fieldView, value);\n      }\n    });\n\n    struct[DATA].view = view;\n    if (free) struct[DATA].free = free;\n  }\n}\n\n\n// Creates a new class that will create new struct instances\n// (this returns a constructor)\nclass Struct {\n  constructor(fields = {}, opt = {}) {\n    class StructType extends AbstractStructType {}\n\n    // keep metadata on the struct constructor itself\n    StructType.fields = new Map();\n    StructType.packed = ('packed' in opt) ? !!opt.packed : false;\n    StructType.alignment = opt.alignment || 0;\n    StructType.isStruct = true;\n\n    let offset = 0;\n\n    // preserve field insertion order with [[OwnPropertyKeys]]\n    Object.getOwnPropertyNames(fields).forEach((name) => {\n      const type = parseType(fields[name]);\n\n      if (!opt.alignment && type.alignment > StructType.alignment) {\n        StructType.alignment = type.alignment;\n      }\n\n      if (!StructType.packed && offset % type.alignment !== 0) {\n        offset += type.alignment - (offset % type.alignment);\n      }\n\n      StructType.fields.set(name, { name, offset, type });\n      offset += type.width;\n    });\n\n    StructType.width = (offset % StructType.alignment)\n      ? offset + StructType.alignment - (offset % StructType.alignment)\n      : offset;\n\n    // define getter / setter behavior for each field\n    // these will read / write each field to memory according to its type\n    StructType.fields.forEach((field, name) => {\n      Object.defineProperty(StructType.prototype, name, {\n        enumerable: true,\n\n        get() {\n          if (!this[DATA].view) {\n            return this[DATA].temp[name];\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          return field.type.read(view, this[DATA].free);\n        },\n\n        set(value) {\n          // fudging for ease of use:\n          if (typeof value === 'string' && field.type === types.string) {\n            value = new CString(value);\n          }\n\n          if (!this[DATA].view) {\n            this[DATA].temp[name] = value;\n            return;\n          }\n\n          const view = vslice(this[DATA].view, field.offset, field.type.width);\n          field.type.write(view, value);\n        },\n      });\n    });\n\n    return StructType;\n  }\n}\n\n\nexport default Struct;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Struct.js","import { Wrapper, cwrap, ccall } from './Wrapper';\nimport Struct from './Struct';\nimport demangle from './demangle';\nimport { types, Pointer, CString, CustomType } from './types';\nimport rust from './rust';\n\nimport { encodeUTF8, decodeUTF8 } from './encoding';\nconst _encodeUTF8 = encodeUTF8;\nconst _decodeUTF8 = decodeUTF8;\n\n\nexport default {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  Pointer,\n  CustomType,\n  CString,\n  demangle,\n  rust,\n  _encodeUTF8,\n  _decodeUTF8,\n};\n\nexport {\n  Wrapper,\n  cwrap,\n  ccall,\n  Struct,\n  types,\n  Pointer,\n  CustomType,\n  CString,\n  demangle,\n  rust,\n  _encodeUTF8,\n  _decodeUTF8,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { Pointer, CString } from './types';\nimport { Encoder, Decoder } from './encoding';\nimport { assert } from './misc';\nimport demangle from './demangle';\n\n\nconst numbers = new Set([\n  'int8', 'int16', 'int32', 'int64',\n  'uint8', 'uint16', 'uint32', 'uint64',\n  'float', 'double',\n  'u8', 'u16', 'u32', 'u64',\n  'i8', 'i16', 'i32', 'i64',\n  'f32', 'f64',\n  'schar', 'short', 'int', 'long',\n  'char', 'uchar', 'ushort', 'uint', 'ulong',\n  'size_t',\n  'usize',\n]);\n\n\nfunction areValid(types) {\n  return types.every(type =>\n    type === null ||\n    type === undefined ||\n    type === 'void' ||\n    type === 'number' ||\n    type === 'boolean' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type === 'array' ||\n    numbers.has(type) ||\n    type.isStruct ||\n    type.isPointer);\n}\n\n\n// a node fetch polyfill that won't trigger webpack\n// idea borrowed from:\n// https://github.com/dcodeIO/webassembly/blob/master/src/index.js#L223\nlet fs;\nfunction fetch_polyfill(file) {\n  return new Promise((resolve, reject) => {\n    (fs || (fs = eval('equire'.replace(/^/, 'r'))('fs'))).readFile(\n      file,\n      function(err, data) {\n        return (err)\n          ? reject(err)\n          : resolve({\n              arrayBuffer: () => Promise.resolve(data),\n              ok: true,\n            });\n      }\n    );\n  });\n}\n\n\nconst fetchFn = (typeof fetch === 'function' && fetch) || fetch_polyfill;\n\n\n// gets the wasm at a url and instantiates it.\n// checks if streaming instantiation is available and uses that\nfunction fetchAndInstantiate(url, imports) {\n  return fetchFn(url)\n    .then((resp) => {\n      if (!resp.ok) {\n        throw new Error(`Got a ${resp.status} fetching wasm @ ${url}`);\n      }\n\n      const wasm = 'application/wasm';\n      const type = resp.headers && resp.headers.get('content-type');\n\n      return (WebAssembly.instantiateStreaming && type === wasm)\n        ? WebAssembly.instantiateStreaming(resp, imports)\n        : resp.arrayBuffer().then(buf => WebAssembly.instantiate(buf, imports));\n    })\n    .then(result => result.instance);\n}\n\n\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('wrapper-data')\n  : '__data';\n\n\nclass Wrapper {\n  constructor(signatures, opts = {}) {\n    // Keep internal info behind the DATA symbol, try to minimize footprint so\n    // wrapped function names don't conflict with whats already here.(Like if\n    // someone had a method called \"memory()\", it would've been a problem)\n    // Same strategy with the \"__\" prefixed object methods.\n    this[DATA] = {\n      instance: null,\n      imports: null,\n      signatures: new Set(),\n      allocations: new Map(),\n      memory: opts.memory,\n      debug: !!opts.debug,\n    };\n\n    Object.entries(signatures).forEach(([fn, [returnType, argTypes = []]]) => {\n      // check for name collisions:\n      assert(fn !== 'exports', '`exports` is a reserved wrapper name');\n      assert(fn !== 'utils', '`utils` is a reserved wrapper name');\n      assert(fn !== 'imports', '`imports` is a reserved wrapper method name');\n      assert(fn !== 'fetch', '`fetch` is a reserved wrapper method name');\n      assert(fn !== 'use', '`use` is a reserved wrapper method name');\n\n      // validate arg types\n      assert(argTypes.every(arg => !!arg), `'${fn}' has undefined types`);\n      assert(areValid([returnType]), `'${fn}' has invalid types`);\n      assert(areValid(argTypes), `'${fn}' has invalid types`);\n\n      this[DATA].signatures.add({ fnName: fn, returnType, argTypes });\n    });\n\n    // exposing some methods via `.utils`\n    this.utils = {\n      readString:   this.__readString.bind(this),\n      writeString:  this.__writeString.bind(this),\n      writeArray:   this.__writeArray.bind(this),\n      readStruct:   this.__readStruct.bind(this),\n      writeStruct:  this.__readStruct.bind(this),\n      readPointer:  this.__readPointer.bind(this),\n      writePointer: this.__readPointer.bind(this),\n\n      allocate: function(value) {\n        assert('ref' in value, 'This method is for Pointer / Structs / CStrings');\n\n        (value instanceof Pointer || value instanceof CString)\n          ? this.__writePointer(value)\n          : this.__writeStruct(value);\n      }.bind(this),\n\n      free: function(value) {\n        ('ref' in value)\n          ? this.__free(value.ref())\n          : this.__free(value);\n      }.bind(this),\n    };\n\n    this.exports = null;\n    this.__free = this.__free.bind(this); // convenience bind\n  }\n\n  // takes an import object or a function what will produce a import object\n  imports(arg, defaults = true) {\n    const wrap = (...args) => {\n      // function to wrap is always the last argument\n      const fn = args.pop();\n      // two argument formats (this might be a bad idea):\n      //   * with return type: wrap([returnType, [...argTypes]], fn)\n      //   * no return type: wrap(arg1, arg2, ..., fn)\n      //\n      const types = (Array.isArray(args[0])) ? args[0] : [null, args];\n      // detructure into appropriate vars\n      const [returnType, argTypes = []] = types;\n\n      assert(areValid(argTypes), `Import has invalid types: ${argTypes}`);\n      assert(areValid([returnType]), `Import has invalid types: ${returnType}`);\n\n      return (...raw) => {\n        const value = fn(...raw.map((r, i) => this.__out(r, argTypes[i])));\n\n        if (returnType && returnType !== 'void') {\n          return this.__in(value, returnType);\n        }\n      };\n    };\n\n    const env = {\n      print:  wrap('string', str => console.log(str)),\n      eprint: wrap('string', str => console.error(str)),\n\n      trace:  wrap('string', (str) => {\n        throw new Error(str);\n      }),\n\n      _abort(errCode) {\n        throw new Error(`wasm aborting: ${errCode}`);\n      },\n\n      _exit(exitCode) {\n        if (exitCode) throw new Error(`wasm exit error: ${exitCode}`);\n      },\n\n      _grow() {},\n    };\n\n    const obj = (typeof arg === 'function')\n      ? arg(wrap)\n      : arg;\n\n    if (defaults) obj.env = Object.assign(env, obj.env);\n    this[DATA].imports = obj;\n\n    return obj;\n  }\n\n  fetch(url) {\n    const imports = this[DATA].imports || this.imports({});\n\n    return fetchAndInstantiate(url, imports).then((instance) => {\n      this.__link(instance);\n      return this;\n    });\n  }\n\n  use(instance) {\n    assert(instance instanceof WebAssembly.Instance,\n      '.use(instance) requires a WebAssembly.Instance');\n\n    this.__link(instance);\n    return this;\n  }\n\n  __link(instance) {\n    const memory = this[DATA].memory ||\n                   instance.exports.memory ||\n                   (this[DATA].imports.env && this[DATA].imports.env.memory);\n\n    assert(!!memory, '' +\n      'Wrapper needs access to your WebAssemmbly memory. It looks for this in' +\n      'either your `imports.env.memory` or `exports.env.memory`. If you don\\'t' +\n      'use either, you need to add it in the options with `new Wrapper`');\n\n    this.exports = instance.exports;\n    this[DATA].instance = instance;\n    this[DATA].memory = memory;\n\n    this[DATA].signatures.forEach(({ fnName, returnType, argTypes }) => {\n      const fn = this.exports[fnName];\n      assert(!!fn, `Fn '${fnName}' missing from wasm exports`);\n\n      this[fnName] = this.__wrap(fn, argTypes, returnType);\n    });\n  }\n\n  __wrap(fn, argTypes, returnType) {\n    return function(...args) {\n      const stack = [];\n      const ffi_args = args.map((arg, i) => this.__in(arg, argTypes[i], stack));\n\n      let value;\n\n      try {\n        value = fn(...ffi_args);\n      } catch (err) {\n        throw demangle(err);\n      }\n\n      stack.forEach(ptr => this.__free(ptr));\n\n      if (returnType && returnType !== 'void') {\n        return this.__out(value, returnType);\n      }\n    };\n  }\n\n  // wrap a variable heading into a wasm function\n  __in(value, type, stack) {\n    assert(!!type, 'No arg type was specified for function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__writeString(value, stack);\n    if (type === 'array') return this.__writeArray(value, stack);\n    if (type.isStruct) return this.__writeStruct(value);\n    if (type.isPointer) return this.__writePointer(value);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  // wrap a variable heading out of a wasm function\n  __out(value, type) {\n    assert(!!type, 'No arg type was specified for function');\n\n    if (type === 'number' || numbers.has(type)) return value;\n    if (type === 'boolean' || type === 'bool') return !!value;\n    if (type === 'string') return this.__readString(value);\n    if (type.isStruct) return this.__readStruct(value, type);\n    if (type.isPointer) return this.__readPointer(value, type);\n\n    throw new Error(`Unknown type: \\n${JSON.stringify(type)}`);\n  }\n\n  __allocate(size) {\n    assert(!!this.exports.allocate && !!this.exports.deallocate,\n      \"Missing allocate/deallocate fns in wasm exports, can't allocate memory\");\n\n    const ptr = this.exports.allocate(size);\n    assert(!!ptr, 'allocate failed');\n\n    if (this[DATA].debug) console.log('Alloc: %s (size=%s)', ptr, size);\n    this[DATA].allocations.set(ptr, size);\n\n    return ptr;\n  }\n\n  __free(ptr, optSize) {\n    const size = optSize || this[DATA].allocations.get(ptr);\n    if (this[DATA].debug) console.log('Free: %s (size=%s)', ptr, size);\n\n    this.exports.deallocate(ptr, size);\n    this[DATA].allocations.delete(ptr);\n  }\n\n  __view(start, length) {\n    return new DataView(this[DATA].memory.buffer, start, length);\n  }\n\n  __readString(ptr) {\n    const view = new Uint8Array(this[DATA].memory.buffer);\n\n    // find end of string (null byte)\n    let end = ptr;\n    while (view[end]) ++end;\n\n    // subarray uses same underlying ArrayBuffer\n    const buf = new Uint8Array(view.subarray(ptr, end));\n    const str = (new Decoder()).decode(buf);\n\n    return str;\n  }\n\n  __writeString(str, stack) {\n    const buf = (new Encoder()).encode(str);\n    const len = buf.byteLength + 1;\n\n    const ptr = this.__allocate(len);\n    if (stack) stack.push(ptr);\n\n    const view = new Uint8Array(this[DATA].memory.buffer);\n    view.set(buf, ptr);\n    view[ptr + len - 1] = 0;\n\n    return ptr;\n  }\n\n  __writeArray(arr, stack) {\n    assert(arr instanceof ArrayBuffer || ArrayBuffer.isView(arr),\n      'Argument must be an `ArrayBuffer` or a `DataView` (like `Uint8Array`)');\n\n    const buf = (ArrayBuffer.isView(arr))\n      ? new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength)\n      : new Uint8Array(arr);\n\n    const ptr = this.__allocate(buf.byteLength);\n    if (stack) stack.push(ptr);\n\n    const view = new Uint8Array(this[DATA].memory.buffer);\n    view.set(buf, ptr);\n\n    return ptr;\n  }\n\n  __readStruct(ptr, StructType) {\n    assert(!!StructType, 'No struct StructType given');\n\n    const view = this.__view(ptr, StructType.width);\n    const struct = StructType.read(view, this.__free);\n\n    return struct;\n  }\n\n  __writeStruct(struct) {\n    // if struct has already been allocated:\n    if (struct.ref()) return struct.ref();\n\n    const StructType = struct.constructor;\n    const ptr = this.__allocate(StructType.width);\n    const view = this.__view(ptr, StructType.width);\n\n    const allocPointers = (sub) => {\n      sub.constructor.fields.forEach((field, name) => {\n        if (field.type.isStruct && sub[name]) {\n          allocPointers(sub[name]);\n        }\n\n        if (field.type.isPointer && sub[name]) {\n          this.__writePointer(sub[name]);\n        }\n      });\n    };\n\n    allocPointers(struct);\n    StructType.write(view, struct, this.__free);\n\n    return ptr;\n  }\n\n  __readPointer(ptr, ptrType) {\n    assert(!!ptrType, 'No pointer type given');\n\n    // get the size of what the pointer points to\n    const view = this.__view(ptr, ptrType.type.width);\n\n    // handle pointer of a pointer cases (structs are pointers too here)\n    if (ptrType.type.isStruct || ptrType.type.isPointer) {\n      return ptrType.read(view, this.__free);\n    }\n\n    const pointer = new Pointer(ptrType.type);\n    pointer.attach(view, this.__free);\n\n    return pointer;\n  }\n\n  __writePointer(pointer) {\n    if (pointer.ref()) return pointer.ref();\n\n    // allocate space for what the pointer points to\n    const addr = this.__allocate(pointer.type.width);\n    const view = this.__view(addr, pointer.type.width);\n\n    // attach wasm memory to pointer and write the pointed-to data\n    pointer.attach(view, this.__free);\n\n    return addr;\n  }\n}\n\n\nfunction cwrap(instance, fnName, returnType = null, argTypes = []) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.cwrap() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].bind(wrapper);\n}\n\nfunction ccall(instance, fnName, returnType = null, argTypes = [], ...args) {\n  assert(instance instanceof WebAssembly.Instance,\n    '.ccall() requires a ready WebAssembly.Instance');\n\n  const wrapper = new Wrapper({ [fnName]: [returnType, argTypes] });\n  wrapper.use(instance);\n\n  return wrapper[fnName].call(wrapper, ...args);\n}\n\n\nexport { Wrapper, cwrap, ccall };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Wrapper.js","import Struct from './Struct';\nimport { types, parseType, Pointer } from './types';\nimport { Encoder, Decoder } from './encoding';\nimport { assert, vslice } from './misc';\n\n\n// get the symbol for struct-data since we need access here\nconst DATA = (typeof Symbol !== 'undefined')\n  ? Symbol.for('struct-data')\n  : '__data';\n\n\n// helper fn, overrides free to be free(true) by default\nfunction extend(StructType) {\n  class RustType extends StructType {\n    free() {\n      super.free(true);\n    }\n  }\n\n  Object.assign(RustType, StructType);\n  return RustType;\n}\n\n\nfunction RustTuple(...tupleTypes) {\n  const fields = {};\n\n  tupleTypes.forEach((type, i) => {\n    fields[i] = parseType(type);\n  });\n\n  return new Struct(fields);\n}\n\n\nfunction RustVector(typedef) {\n  const type = parseType(typedef);\n\n  const Vector = extend(new Struct({\n    ptr: types.pointer(type),\n    cap: 'usize',\n    len: 'usize',\n    /* values */\n  }));\n\n  Object.defineProperty(Vector.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const arrayType = parseType([type, this.len]);\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, this[DATA].free);\n    },\n\n    set(values) {\n      const len = values.length;\n\n      this.ptr = new Pointer([type, len], values);\n      this.len = len;\n      this.cap = len;\n    },\n  });\n\n  return Vector;\n}\n\n\nfunction RustSlice(typedef) {\n  const type = parseType(typedef);\n\n  const Slice = extend(new Struct({\n    ptr: types.pointer(type),\n    len: 'usize',\n    /* values */\n  }));\n\n  Object.defineProperty(Slice.prototype, 'values', {\n    enumerable: true,\n\n    get() {\n      const arrayType = parseType([type, this.len]);\n      const memory = this[DATA].view.buffer;\n      const view = new DataView(memory, this.ptr.ref(), arrayType.width);\n\n      return arrayType.read(view, this[DATA].free);\n    },\n\n    set(values) {\n      const len = values.length;\n\n      this.ptr = new Pointer([type, len], values);\n      this.len = len;\n    },\n  });\n\n  return Slice;\n}\n\n\nfunction RustString() {\n  const RString = extend(new Struct({\n    ptr: types.pointer('u8'),\n    cap: 'usize',\n    len: 'usize',\n    /* value */\n  }));\n\n  Object.defineProperty(RString.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const buf = new Uint8Array(memory, this.ptr.ref(), this.len);\n\n      return (new Decoder()).decode(buf);\n    },\n\n    set(str) {\n      const buf = (new Encoder()).encode(str);\n      const len = buf.length;\n\n      this.ptr = new Pointer(['u8', len], buf);\n      this.len = len;\n      this.cap = len;\n    },\n  });\n\n  RString.prototype.toString = function() {\n    return this.value;\n  };\n\n  return RString;\n}\n\n\nfunction RustStr() {\n  const RStr = extend(new Struct({\n    ptr: types.pointer('u8'),\n    len: 'usize',\n    /* value */\n  }));\n\n  Object.defineProperty(RStr.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const memory = this[DATA].view.buffer;\n      const buf = new Uint8Array(memory, this.ptr.ref(), this.len);\n\n      return (new Decoder()).decode(buf);\n    },\n\n    set(str) {\n      const buf = (new Encoder()).encode(str);\n      const len = buf.length;\n\n      this.ptr = new Pointer(['u8', len], buf);\n      this.len = len;\n    },\n  });\n\n  RStr.prototype.toString = function() {\n    return this.value;\n  };\n\n  return RStr;\n}\n\n\nfunction RustOption(typedef, isNonNullable = false, tagSize) {\n  const type = parseType(typedef);\n  let discriminant;\n\n  if (tagSize) discriminant = types[`uint${tagSize * 8}`];\n  else if (type.alignment === 1) discriminant = 'uint8';\n  else if (type.alignment === 2) discriminant = 'uint16';\n  else discriminant = 'uint32';\n\n  const fields = (isNonNullable)\n    ? { value: type }\n    : { discriminant, value: type };\n\n  const Option = new Struct(fields);\n\n  Object.assign(Option.prototype, {\n    isSome() {\n      return ('discriminant' in fields) ? !!this.discriminant : !!this.value;\n    },\n\n    isNone() {\n      return !this.isSome();\n    },\n\n    expect(msg) {\n      if (!this.isSome()) throw new Error(msg);\n      return this.value;\n    },\n\n    unwrap() {\n      if (!this.isSome()) throw new Error('Error unwrapping none');\n      return this.value;\n    },\n\n    unwrapOr(defaultValue) {\n      return (this.isSome()) ? this.value : defaultValue;\n    },\n\n    unwrapOrElse(fn) {\n      return (this.isSome()) ? this.value : fn();\n    },\n  });\n\n  return Option;\n}\n\n\nfunction RustEnum(obj, tagSize = 4) {\n  const variants = Object.getOwnPropertyNames(obj);\n  const vtypes = variants.map(name => parseType(obj[name]));\n  const discriminant = types[`uint${tagSize * 8}`];\n\n  const StructType = new Struct({\n    discriminant,\n    /* value */\n  });\n\n  class Enum extends StructType {\n    constructor(variant) {\n      super();\n      if (variant) this._set(variant);\n    }\n\n    _set(variant) {\n      assert(Object.keys(variant).length === 1, 'Enum value must be a variant');\n\n      const [name, value] = Object.entries(variant)[0];\n\n      this.discriminant = variants.indexOf(name);\n      this.value = value;\n    }\n\n    tag() {\n      const tag = this.discriminant;\n      assert(tag <= variants.length, 'Enum discriminant > than # of variants');\n      return tag;\n    }\n\n    free(recursive = false) {\n      const type = vtypes[this.tag()];\n\n      if (recursive && type.isPointer || type.isStruct) {\n        this.value.free(recursive);\n      }\n\n      this[DATA].free(this.ref(), Enum.width);\n      this[DATA].free = null;\n      this[DATA].view = null;\n    }\n\n    name() {\n      return variants[this.tag()];\n    }\n\n    is(name) {\n      return (variants.indexOf(name) === this.tag());\n    }\n\n    match(arms) {\n      const name = variants[this.tag()];\n      const val = this.value;\n\n      if (name in arms) {\n        return (typeof arms[name] === 'function') ? arms[name](val) : arms[name];\n      }\n\n      if ('_' in arms) {\n        return (typeof arms._ === 'function') ? arms._(val) : arms._;\n      }\n    }\n\n    static write(view, struct, free) {\n      const tag = struct.tag();\n      const type = vtypes[tag];\n      const value = (struct.ref()) ? struct.value : struct[DATA].temp.value;\n\n      const field_1 = vslice(view, 0, discriminant.width);\n      discriminant.write(field_1, tag);\n\n      const field_2 = vslice(view, discriminant.width, type.width);\n      type.write(field_2, value);\n\n      struct[DATA].view = view;\n      if (free) struct[DATA].free = free;\n    }\n  }\n\n  Object.defineProperty(Enum.prototype, 'value', {\n    enumerable: true,\n\n    get() {\n      const addr = this.ref() + discriminant.width;\n      const memory = this[DATA].view.buffer;\n\n      const type = vtypes[this.tag()];\n      const view = new DataView(memory, addr, type.width);\n\n      return type.read(view, this[DATA].free);\n    },\n\n    set(value) {\n      this[DATA].temp.value = value;\n    },\n  });\n\n  Object.assign(Enum, StructType);\n\n  const max = arr => arr.reduce((acc, i) => (i > acc) ? i : acc, 0);\n  const width = discriminant.width + max(vtypes.map(t => t.width));\n  const align = max([...vtypes.map(t => t.alignment), discriminant.alignment]);\n\n  Enum.width = (width % align)\n    ? width + align - (width % align)\n    : width;\n\n  return Enum;\n}\n\n\nconst rust = {\n  tuple: RustTuple,\n  Tuple: function ctor(type, values) {\n    return new (RustTuple(...type))([...values]);\n  },\n\n  vector: RustVector,\n  Vector: function ctor(type, values) {\n    return new (RustVector(type))({ values });\n  },\n\n  slice: RustSlice,\n  Slice: function ctor(type, values) {\n    return new (RustSlice(type))({ values });\n  },\n\n  string: RustString(),\n  String: function ctor(str) {\n    return new (RustString())({ value: str });\n  },\n\n  str: RustStr(),\n  Str: function ctor(str) {\n    return new (RustStr())({ value: str });\n  },\n\n  option: RustOption,\n  Option: function ctor(type, value, ...opts) {\n    return new (RustOption(type, ...opts))({\n      value,\n      discriminant: (typeof value === 'undefined') ? 0 : 1,\n    });\n  },\n\n  Some: function ctor(...args) {\n    return new rust.Option(...args);\n  },\n\n  None: function ctor(type, ...opts) {\n    return new rust.Option(type, undefined, ...opts);\n  },\n\n  enum: RustEnum,\n};\n\n\nexport default rust;\n\n\n\n// WEBPACK FOOTER //\n// ./src/rust.js"],"sourceRoot":""}